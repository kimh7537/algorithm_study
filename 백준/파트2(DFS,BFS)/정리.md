## 2852
1. prev를 사용해서 이전값 이용하는 방법 (이때 `#define prev aaa`과 같은 형식으로 지정해두기)
2. 시간과 같은 값이 주어지면 단위를 하나로 바꾸는게 편함 ex. 01:30 -> 90초

---
## 9012
1. `stack<> stk` 의 메서드 `stk.empty()` (스택이 비었는지 확인) 기억해두기

---
## 4949
1. `stack`과 같은 자료구조에서 `top()`을 하기전에 무조건 스택의 사이즈가 0이 아닌지 확인해야함
2. `if(stack.size() == 0 || stack.top() == ']')`

   -> `if(true || false)`는 앞의 true만 확인하면 뒤의 false는 탐색하지 않음
   
   -> `if(false || true)`는 앞의 false를 확인하고 뒤의 true로 넘어와 탐색함

---
## 14502
1. 문제는 먼저 모든 경우의 수를 **무식하게** 고려해보기
2. 안될것 같으면 효율적인 경우의 수를 고려해보기

**문제 시간복잡도 구해보기**
1. 최대 범위를 기반으로 시간복잡도 구하기
2. 2차원 배열의 최대 범위(8*8=64)
3. `64C3(64개 중 임의로 3개의 벽 세우기)` * `(64(bfs로 탐색) + 64(바이러스 퍼져나감))` -> `약 400만`
4.  `1000만 이하` or `1억 이하`라면 시간복잡도 초과안했다고 가정
